import { Prisma } from '@prisma/client';
import camelCase from 'camelcase';
import { prisma } from './index';

import {
  membershipSources,
  fundingStages,
  imageRelations,
  industryCategories,
  industryTags,
  locations,
  memberRelations,
  members,
  originalImages,
  skills,
  teamMemberRoles,
  teamRelations,
  teams,
  technologies,
  memberRoles,
  projects,
  projectRelations,
  eventLocations,
  events,
  eventGuests,
  focusAreas,
  teamFocusAreas,
  projectFocusAreas,
  discoveryQuestions,
} from './fixtures';

/**
 * Truncate all public tables (except _prisma_migrations) and reset identities.
 * Uses CASCADE to handle FK dependencies.
 */
async function resetAllTables() {
  await prisma.$executeRawUnsafe(`
    DO
    $func$
    BEGIN
        EXECUTE
        (SELECT 'TRUNCATE TABLE ' || string_agg(oid::regclass::text, ', ') || ' RESTART IDENTITY CASCADE'
            FROM   pg_class
            WHERE  relkind = 'r'  -- only tables
            AND    relnamespace = 'public'::regnamespace
            AND    relname != '_prisma_migrations'
        );
    END
    $func$;
  `);
  console.log('ðŸ”„ Reset all tables\n');
}

/**
 * Generic loader for fixtures with optional relation updates.
 * - Creates many (skipDuplicates)
 * - Then applies relation updates one-by-one (Prisma limitation)
 */
async function load(fixtures: Array<Record<string, any>>) {
  for (const fixture of fixtures) {
    const model = Object.keys(fixture)[0]; // e.g., 'MemberRole', 'Team', etc.
    const modelBlock = fixture[model];

    const fixturesValue = modelBlock?.fixtures ?? modelBlock;
    const fixturesToCreate =
      typeof fixturesValue === 'function'
        ? await fixturesValue().then((data: any[]) => Promise.all(data))
        : fixturesValue;

    const relationsToConnect = modelBlock?.relations
      ? await modelBlock.relations(fixturesToCreate).then((data: any[]) => Promise.all(data))
      : null;

    await prisma[model].createMany({
      data: fixturesToCreate,
      skipDuplicates: true,
    });
    console.log(`âœ… Added ${model} data\n`);

    // Relation updates must be sent one-by-one
    if (!relationsToConnect) continue;
    for (const relation of relationsToConnect) {
      await prisma[camelCase(model)].update(relation);
    }
    console.log(`âœ… Updated ${model} with its relations\n`);
  }
}

/**
 * Seed TeamFundraisingProfile rows for all teams currently in DB.
 * New structure: upload slots instead of legacy URLs.
 * We initialize with nulls for optional FKs to Upload.
 */
async function seedTeamFundraisingProfilesFromDb() {
  const dbTeams = await prisma.team.findMany({ select: { uid: true } });
  if (!dbTeams.length) {
    console.log('â„¹ï¸ No teams found â€” skipping TeamFundraisingProfile seeding\n');
    return;
  }

  const now = new Date();
  const rows = dbTeams.map((t) => ({
    // uid will be generated by Prisma (cuid())
    teamUid: t.uid,
    focusAreaUid: null,
    fundingStageUid: null,

    // NEW: upload FK slots (no legacy URLs)
    onePagerUploadUid: null,
    videoUploadUid: null,

    status: 'DRAFT' as const,
    createdAt: now,
    updatedAt: now,
    lastModifiedBy: null,
  }));

  await prisma.teamFundraisingProfile.createMany({
    data: rows,
    skipDuplicates: true, // respects unique(teamUid)
  });

  console.log(`âœ… Added TeamFundraisingProfile for ${rows.length} teams\n`);
}

async function main() {
  await resetAllTables();

  // Load core fixtures in a FK-safe order
  await load([
    { [Prisma.ModelName.MemberRole]: memberRoles },
    { [Prisma.ModelName.Skill]: skills },
    { [Prisma.ModelName.FundingStage]: fundingStages },
    { [Prisma.ModelName.MembershipSource]: membershipSources },
    { [Prisma.ModelName.IndustryCategory]: industryCategories },
    { [Prisma.ModelName.IndustryTag]: industryTags },
    { [Prisma.ModelName.Location]: locations },
    { [Prisma.ModelName.Technology]: technologies },
    {
      [Prisma.ModelName.Image]: {
        fixtures: originalImages,
        relations: imageRelations,
      },
    },
    { [Prisma.ModelName.Team]: { fixtures: teams, relations: teamRelations } }, // Teams FIRST
    {
      [Prisma.ModelName.Member]: {
        fixtures: members,
        relations: memberRelations,
      },
    },
    { [Prisma.ModelName.TeamMemberRole]: teamMemberRoles },
    {
      [Prisma.ModelName.Project]: {
        fixtures: projects,
        relations: projectRelations,
      },
    },
    { [Prisma.ModelName.PLEventLocation]: { fixtures: eventLocations } },
    { [Prisma.ModelName.PLEvent]: { fixtures: events } },
    { [Prisma.ModelName.PLEventGuest]: { fixtures: eventGuests } },
    { [Prisma.ModelName.FocusArea]: focusAreas },
    { [Prisma.ModelName.TeamFocusArea]: { fixtures: teamFocusAreas } },
    { [Prisma.ModelName.ProjectFocusArea]: { fixtures: projectFocusAreas } },
    { [Prisma.ModelName.DiscoveryQuestion]: { fixtures: discoveryQuestions } },
  ]);

  await seedTeamFundraisingProfilesFromDb();
}

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });
